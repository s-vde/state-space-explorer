
#ifndef EXPLORATION_HPP_INCLUDED
#define EXPLORATION_HPP_INCLUDED

#include <chrono>
#include <sys/stat.h>
#include "color_output.hpp"
#include "container_output.hpp"
#include "debug.hpp"
#include "error.hpp"
#include "execution_io.hpp"
#include "program.hpp"
#include "replay.hpp"
#include "state.hpp"
#include "state_io.hpp"
#include "utils_io.hpp"

/*---------------------------------------------------------------------------75*/
/**
 @file exploration.hpp
 @brief Definition of classes ExplorationStatistics and ExplorationBase and 
 class template Exploration<Mode>.
 @author Susanne van den Elsen
 @date 2015
 */
/*---------------------------------------------------------------------------++*/

namespace exploration
{
	using namespace program_model;
	
    class ExplorationStatistics
    {
    public:
		
		// CTOR
		
        ExplorationStatistics();
		
		//
        
        unsigned int nr_explorations() const;
        void increase_nr_explorations();
		
		double time_cpu() const;
		void start_clock();
		void stop_clock();
		
        void dump(const std::string& filename) const;
        
    private:
		
		// TYPES
		
		using wall_clock_t = std::chrono::high_resolution_clock;
		
		// DATA MEMBERS
        
        unsigned int mNrExplorations;
		double mTimeCpu;
		double mTimeWall;
		std::clock_t mTimeCpuStart;
		std::chrono::time_point<wall_clock_t> mTimeWallStart;
		
    }; // end class ExplorationStatistics
	
	class ExplorationBase
	{
	public:
		
		ExplorationBase(
			const scheduler::Program& P,
			const unsigned int max_nr_explorations
		);
		
		ExplorationStatistics statistics() const;
		
	protected:
		
		// TYPES
		
		using transition = Transition<State>;
		using execution = Execution<State>;
		
		// DATA MEMBERS
		
		scheduler::Program mProgram;
		scheduler::schedule_t mSchedule;
		unsigned int mMaxNrExplorations;
		execution mExecution;
		ExplorationStatistics mStatistics;
		bool mDone;
		std::ofstream mLogSchedules;
		
		//
		
		void run_program();
		void create_dir(const std::string& dir) const;
		void log(const unsigned int nr, const std::string& dir);
		
		static const std::string name;
		static std::string outputname();
		
	}; // end class ExplorationBase
	
    /**
     @brief Provides the basic functionality for exploring the state-space
	 of a multithreaded program.
     
     @details An instantation of Exploration<Mode> uses the argument to 
	 template parameter Mode for the (on-the-fly) generation of a set of 
	 schedules/thread-interleavings (i.e. an exploration tree) under which 
	 to explore the program. Thereto, Mode may maintain additional state.
     */
    template<typename Mode>
	class Exploration : public ExplorationBase
    {
    public:
        
		// CTOR
		
		template<typename ... Args>
        explicit Exploration(
			const scheduler::Program& P,
			const unsigned int max_nr_explorations,
			Args ... args)
        : ExplorationBase(P, max_nr_explorations)
        , mMode(mExecution, std::forward<Args>(args) ...)
        , mOutputDir(outputdir()) { }
		
        //

        /**
         @brief Sets up the exploration, runs the program under an initial 
         schedule and traverses the exploration tree generated by Mode 
         (on-the-fly). For every leaf it visits, it runs the input program 
         mProgram under the schedule corresponding to that leaf.
         */
        void run(const scheduler::schedule_t& s={})
        {
            create_dir(mOutputDir);
            // Open scheduler log file here once, opening in append mode is costly
            mLogSchedules.open(mOutputDir + "/schedules.txt");
            scheduler::write_settings(mMode.scheduler_settings());
            mSchedule = s;
            int from = 1;
			mStatistics.start_clock();
            while (!mDone && mStatistics.nr_explorations() < mMaxNrExplorations) {
                mMode.reset();
                run_program();
				if (mStatistics.nr_explorations() > 0 || mMode.check_valid(mExecution.contains_locks())) {
                	update_state(from);
                	if ((mSchedule = mMode.new_schedule(mExecution, mSchedule)).empty()) {
						mDone = true;
						break;
					}
                	from = mSchedule.size();
				} else { ERROR(full_name(), "Invalid input program"); break; }
            }
            close();
        }
		
		// #todo void resume()
        
    private:
		
        // DATA MEMBERS
		
        Mode mMode;
		std::string mOutputDir;
		
        // HELPER FUNCTIONS
		
        /**
         @brief Runs the input program mProgram under the current schedule,
         updates mExecution and mSchedule according to the performed 
         Execution, calls mMode to update its state, and updates log files.
         */
        void run_program()
        {
            mMode.write_scheduler_files();
			ExplorationBase::run_program();
        }
        
        void update_statistics()
        {
            mStatistics.increase_nr_explorations();
            mMode.update_statistics(mExecution);
        }

        /**
         @brief Loops through the Transitions of mExecution and lets Mode
         restore and update its internal state.
         */
        void update_state(const unsigned int from)
        {
            update_statistics();
            mSchedule = scheduler::schedule(mExecution);
            log(mStatistics.nr_explorations(), mOutputDir);
            DEBUGFNL(outputname(), "UPDATE_STATE", "from=" << from, "");
            for (auto& t : mExecution)
            {
                if (t.index() < from)   { mMode.restore_state(t);               }
                else                    { mMode.update_state(mExecution, t);    }
            }
            dump_branch(mStatistics.nr_explorations());
        }
        
        void close()
        {
			mStatistics.stop_clock();
			const std::string statistics = mOutputDir + "/statistics.txt";
			mStatistics.dump(statistics);
			mLogSchedules.close();
            mMode.close(statistics);
			system(("python -c 'import search_tree; print search_tree.tree_to_dot(\"" + mOutputDir + "\")'").c_str());
        }
        
        // LOGGING
        
        std::string outputdir() const
        {
            std::string str("output/");
            str += mProgram.file();
            str += std::to_string(mProgram.nr_threads());
            str += "/";
            str += mMode.path();
            return str;
        }
        
        template<typename OutStream>
        void dump_state(OutStream& os, const transition& t) const
        {
            os << t.pre() << " ";
            mMode.dump_state(os, t.index()-1);
            os << std::endl;
        }
        
        void dump_branch(const unsigned int nr) const
        {
            std::ofstream ofs(mOutputDir + "/exploration" + std::to_string(nr) + ".txt");
            for (const auto& t : mExecution) {
                dump_state(ofs, t);
                ofs << to_short_string(t) << std::endl;
            }
            ofs.close();
        }
        
        void dump_state(const unsigned int i) const
        {
            mMode.dump_state(i);
        }
        
        // OUTPUT
        
        static std::string full_name()
        {
            std::string full_name = name;
            full_name += "<";
            full_name += Mode::full_name();
            full_name += ">";
            return full_name;
        }
    }; // end class template Exploration<Mode>
} // end namespace exploration

#endif
